<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mlib.core.qt &mdash; Maya open source Python/Qt tools 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Maya open source Python/Qt tools 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Maya open source Python/Qt tools 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for mlib.core.qt</h1><pre>
__author__ = 'Nathan'

import os
import sys
import time
import logging
import inspect
import subprocess
import __main__

from functools import partial, update_wrapper

log = logging.getLogger(__name__)


#Find the best way to provide a switch for the order....
load_order = ['pyqt', 'pyside']

#We have to import these the "hard" way rather than with __import__ because
# some people like something called "Auto-Completion" :)
for library in load_order:
	if library == 'pyside':
		try:
			from PySide import QtGui, QtCore
			import shiboken
			import pysideuic as uic
			import xml.etree.cElementTree as xml
			import cStringIO as StringIO
		except ImportError:
			continue

		try: from PySide import QtDeclarative
		except ImportError: pass
		try: from PySide import QtMultimedia
		except: pass
		try: from PySide import QtNetwork
		except: pass
		try: from PySide import QtOpenGL
		except: pass
		try: from PySide import QtOpenVG
		except: pass
		try: from PySide import QtScript
		except: pass
		try: from PySide import QtScriptTools
		except: pass
		try: from PySide import QtSql
		except: pass
		try: from PySide import QtSvg
		except: pass
		try: from PySide import QtWebKit
		except: pass
		try: from PySide import QtXml
		except: pass
		try: from PySide import QtXmlPatterns
		except: pass
		try: from PySide import phonon
		except: pass
		try:
			from PySide.phonon import Phonon
			sys.modules[__name__+'.phonon'] = phonon
		except: pass

		QtCore.pyqtSignal = QtCore.Signal
		QtCore.pyqtSlot = QtCore.Slot
		QtCore.pyqtProperty = QtCore.Property

		qt_lib = library
		break

	elif library == 'pyqt':
		import sip
		try:
			sip.setapi('QDate', 2)
			sip.setapi('QDateTime', 2)
			sip.setapi('QString', 2)
			sip.setapi('QTextStream', 2)
			sip.setapi('QTime', 2)
			sip.setapi('QUrl', 2)
			sip.setapi('QVariant', 2)
		except ValueError:
			log.exception('Failed to set sip api version for PyQt4, have you imported it before this?')

		try:
			from PyQt4 import QtGui, QtCore, uic
		except ImportError:
			continue

		try: from PyQt4 import QtDeclarative
		except ImportError: pass
		try: from PyQt4 import QtMultimedia
		except: pass
		try: from PyQt4 import QtNetwork
		except: pass
		try: from PyQt4 import QtOpenGL
		except: pass
		try: from PyQt4 import QtOpenVG
		except: pass
		try: from PyQt4 import QtScript
		except: pass
		try: from PyQt4 import QtScriptTools
		except: pass
		try: from PyQt4 import QtSql
		except: pass
		try: from PyQt4 import QtSvg
		except: pass
		try: from PyQt4 import QtWebKit
		except: pass
		try: from PyQt4 import QtXml
		except: pass
		try: from PyQt4 import QtXmlPatterns
		except: pass
		try: from PyQt4 import phonon
		except: pass
		try:
			from PyQt4.phonon import Phonon
			sys.modules[__name__+'.phonon'] = phonon
		except: pass

		QtCore.Signal = QtCore.pyqtSignal
		QtCore.Slot = QtCore.pyqtSlot
		QtCore.Property = QtCore.pyqtProperty

		qt_lib = library
		break


try:
	#Try to load maya...
	import maya.cmds as cmds

	if cmds.internalVar(upd=True) is None:
		raise SystemError('Standalone uninitialized')

	import maya
	import maya.mel as mel
	import maya.OpenMaya as api
	import maya.OpenMayaUI as apiUI

	#Define Callback function to handle our callback wrapper
	mel.eval("global proc Callback(string $description){};")
	has_maya = True
except (ImportError, SystemError, AttributeError):
	has_maya = False


<div class="viewcode-block" id="loadUiFile"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.loadUiFile">[docs]</a>def loadUiFile(uiPath):
	"""
	Load a designer UI xml file in

	:param uiPath: Path to UI file.
		``uiPath`` be a partial path relative to the file calling :py:func:`.loadUiFile`.
		It is also not necessary to include the `.ui` extension.

	:type uiPath: str
	:return: Window Class defined by the input UI file
	:rtype: :py:class:`.DesignerForm`
	"""
	#Add extension if missing..
	if not uiPath.endswith('.ui'):
		uiPath += '.ui'

	if not os.path.isfile(uiPath):
		#Resolve partial path into full path based on the call stack
		frame = inspect.currentframe().f_back  #Back up one from the current frame
		modpath = frame.f_code.co_filename  #Grab the filename from the code object
		base_directory = os.path.dirname(modpath)

		resolvePath = os.path.join(base_directory, uiPath)

		if os.path.isfile(resolvePath):
			uiPath = resolvePath
		else:
			raise ValueError('Could not locate UI file at path: %s' % uiPath)

	#Load the form class, and establish what the base class for the top level is in order to sub-class it
	if qt_lib == 'pyqt':
		#This step is easy with PyQt
		with open(uiPath, 'r') as f:
			form_class, base_class = uic.loadUiType(f)

	elif qt_lib == 'pyside':
		"""
		Pyside lacks the "loadUiType" command :(
		so we have to convert the ui file to py code in-memory first
		and then execute it in a special frame to retrieve the form_class.
		"""
		parsed = xml.parse(uiPath)
		widget_class = parsed.find('widget').get('class')
		form_class = parsed.find('class').text

		with open(uiPath, 'r') as f:
			o = StringIO()
			frame = {}

			#Compile to StringIO object
			uic.compileUi(f, o, indent=0)
			pyc = compile(o.getvalue(), '&lt;string&gt;', 'exec')
			exec pyc in frame

			#Fetch the base_class and form class based on their type in the xml from designer
			form_class = frame['Ui_%s' % form_class]
			base_class = eval('QtGui.%s' % widget_class)

	class WindowClass(form_class, base_class, DesignerForm): pass
	WindowClass._appName = uiPath
	WindowClass._uiPath = uiPath
	WindowClass.ensurePolished = DesignerForm.ensurePolished
	return WindowClass

</div>
<div class="viewcode-block" id="DesignerForm"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm">[docs]</a>class DesignerForm(QtGui.QWidget):
	"""
	Base class for widgets loaded with loadUiType.
	This class provides convenience functions, and manages a few of the more specific features of the loadUiFile function.
	"""
	_uiPath = None
	_appName = None
	_manage_settings = True

	def __init__(self, parent=None):
		super(DesignerForm, self).__init__(parent)
		self.setupUi(self) #Now run the setupUi function for the user
		QtGui.qApp.aboutToQuit.connect(self.close)

		#Store initial settings for reset
		self.__initial_settings = InitialSettings()
		saveLoadSettings(self, settings=self.__initial_settings)

		#Create a settings object for the user if they have us managing their settings
		if self._manage_settings:
			self.__has_loaded = False
			self.settings = getSettings(self._appName, self)

<div class="viewcode-block" id="DesignerForm.showEvent"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.showEvent">[docs]</a>	def showEvent(self, event):
		#If we manage settings, load the state on first show
		if not self.__has_loaded and self._manage_settings:
			self.loadSettings()
			self.__has_loaded = True
</div>
<div class="viewcode-block" id="DesignerForm.closeEvent"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.closeEvent">[docs]</a>	def closeEvent(self, event):
		#If we manage settings save the settings on close
		if self._manage_settings:
			self.saveSettings()
</div>
	@classmethod
<div class="viewcode-block" id="DesignerForm.showUI"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.showUI">[docs]</a>	def showUI(cls, *args, **kwargs):
		"""
		Show a single instance of this form class, closes any previous instances regardless of reloads
		All arguments pass through to the base class.

		.. todo::
			Implement multi-instance window support for windows that want it.
		"""
		ukey = __name__ + '_loadUiWindows'
		windows = __main__.__dict__.setdefault(ukey, {})
		widget = windows.get(cls._uiPath)
		closeAndCleanup(widget)

		windows[cls._uiPath] = cls(*args, **kwargs)
		windows[cls._uiPath].show()
		return windows[cls._uiPath]
</div>
	@classmethod
<div class="viewcode-block" id="DesignerForm.closeUI"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.closeUI">[docs]</a>	def closeUI(cls):
		"""
		Close the visible instance of this form class
		"""
		widget = cls.getVisibleInstance()
		closeAndCleanup(widget)
</div>
	@classmethod
<div class="viewcode-block" id="DesignerForm.getVisibleInstance"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.getVisibleInstance">[docs]</a>	def getVisibleInstance(cls, create=False):
		"""
		Get the visible instance of this form class.
		If create is True, and this window does not already exists,
		it will return the result of showUI with no arguments.

		:param create: Create this ui if none exists
		:type create: bool
		:return: The visible instance if one exists
		:rtype: :py:class:`.DesignerForm` or None
		"""
		ukey = __name__ + '_loadUiWindows'
		windows = __main__.__dict__.setdefault(ukey, {})
		widget = windows.get(cls._uiPath)
		if isValid(widget) and widget.isVisible():
			return widget
		if create:
			return cls.showUI()
		return None
</div>
<div class="viewcode-block" id="DesignerForm.resetSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.resetSettings">[docs]</a>	def resetSettings(self, ignore=None, skipGeometry=False, skipWindowState=False):
		"""
		Reset the window to it's "initial" state from when the UI for was loaded


		:param ignore:
		:param skipGeometry:
		:param skipWindowState:
		"""
		log.info('Resetting window settings!')
		settings = InitialSettings(self.__initial_settings.items())

		if not skipGeometry:
			geom = settings.value('geometry', None)
			if geom:
				settings.setValue('geometry', geom.moveTo(self.geometry().topLeft()))

		saveLoadSettings(self, ignore=ignore, save=False, settings=self.__initial_settings,
		                 skipGeometry=skipGeometry, skipWindowState=skipWindowState)
</div>
<div class="viewcode-block" id="DesignerForm.saveSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.saveSettings">[docs]</a>	def saveSettings(self, ignore=None):
		"""

		:param ignore:
		"""
		saveLoadSettings(self, ignore)
</div>
<div class="viewcode-block" id="DesignerForm.loadSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.loadSettings">[docs]</a>	def loadSettings(self, ignore=None):
		"""

		:param ignore:
		"""
		saveLoadSettings(self, ignore, False)
</div>
<div class="viewcode-block" id="DesignerForm.saveWindowState"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.saveWindowState">[docs]</a>	def saveWindowState(self):
		"""
		Save position/size of window
		"""
		saveLoadSettings(self, windowStateOnly=True)
</div>
<div class="viewcode-block" id="DesignerForm.loadWindowState"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.loadWindowState">[docs]</a>	def loadWindowState(self):
		"""
		Load position/size of window
		"""
		saveLoadSettings(self, save=False, windowStateOnly=True)
</div>
<div class="viewcode-block" id="DesignerForm.close"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.DesignerForm.close">[docs]</a>	def close(self):
		"""
		Slight tweak to the default close function, cleans up the window to avoid memory leaking.

		.. todo::
			Investigate if this is something people actually want, it seems safer this way, but I'm paranoid.

		"""
		QtGui.QWidget.close(self)
		if isValid(self):
			self.deleteLater()
		try:
			del self.__initial_settings
		except AttributeError:
			pass

###-----------------------------------###
###Convience functions to help with Qt###
###-----------------------------------###</div></div>
<div class="viewcode-block" id="getFocusWidget"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.getFocusWidget">[docs]</a>def getFocusWidget():
	"""
	Get the currently focused widget

	:return: Widget with focus currently
	:rtype: QtGui.QWidget or None
	"""
	return QtGui.qApp.focusWidget()

</div>
<div class="viewcode-block" id="getWidgetAtMouse"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.getWidgetAtMouse">[docs]</a>def getWidgetAtMouse():
	"""
	Get the widget under the mouse

	:return: QtGui.QWidget or None
	"""
	currentPos = QtGui.QCursor().pos()
	widget = QtGui.qApp.widgetAt(currentPos)
	return widget

</div>
<div class="viewcode-block" id="qrcToPythonRc"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.qrcToPythonRc">[docs]</a>def qrcToPythonRc(path, target):
	"""
	Given a path to a qrc file, create the target file
	This also tries to checkout the file from perforce if it can.

	:param path: Qrc file path to compile
	:type path: str
	:param target: Target path for compiled python RC file
	:type target: str
	"""
	qt_lib_root = os.path.dirname(QtGui.__file__)
	rcc_exe = os.path.join(qt_lib_root, 'bin', 'pyrcc4.exe')
	proc = subprocess.Popen([rcc_exe, path, '-o', target], shell=True)
	proc.wait()

</div>
<div class="viewcode-block" id="wrapinstance"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.wrapinstance">[docs]</a>def wrapinstance(ptr, base=None):
	"""
	Utility to convert a pointer to a Qt class instance

	:param ptr: Pointer to QObject in memory
	:type ptr: long or Swig instance
	:param base: (Optional) Base class to wrap with (Defaults to QObject, which should handle anything)
	:type base: QtGui.QWidget
	:return: QWidget or subclass instance
	:rtype: QtGui.QWidget
	"""
	if ptr is None:
		return None
	ptr = long(ptr)  #Ensure type
	if qt_lib == 'pyqt':
		base = QtCore.QObject
		return sip.wrapinstance(long(ptr), base)
	elif qt_lib == 'pyside':
		#Pyside makes this a pain for us, since unlike Pyqt it does not return the "best" matching class automatically
		if base is None:
			qObj = shiboken.wrapInstance(long(ptr), QtCore.QObject)
			metaObj = qObj.metaObject()
			cls = metaObj.className()
			superCls = metaObj.superClass().className()
			if hasattr(QtGui, cls):
				base = getattr(QtGui, cls)
			elif hasattr(QtGui, superCls):
				base = getattr(QtGui, superCls)
			else:
				base = QtGui.QWidget
		return shiboken.wrapInstance(long(ptr), base)

</div>
<div class="viewcode-block" id="unwrapinstance"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.unwrapinstance">[docs]</a>def unwrapinstance(obj):
	"""
	Utility to convert a Qt class instance to a pointer

	:param obj: Object to unwrap
	:type obj: Qt Object
	:return: Unwrapped instance pointer
	:rtype: long
	"""
	if obj is None:
		return
	if qt_lib == 'pyqt':
		return sip.unwrapinstance(obj)
	elif qt_lib == 'pyside':
		return shiboken.getCppPointer(obj)

</div>
<div class="viewcode-block" id="isValid"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.isValid">[docs]</a>def isValid(widget):
	"""
	Check if a widget is valid in the backend

	:param widget: QtGui.QWidget
	:return: True if the widget still has a c++ object
	:rtype: bool
	"""
	if widget is None:
		return False

	if qt_lib == 'pyqt':
		if sip.isdeleted(widget):
			return False
	elif qt_lib == 'pyside':
		if not shiboken.isValid(widget):
			return False
	return True

</div>
<div class="viewcode-block" id="closeAndCleanup"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.closeAndCleanup">[docs]</a>def closeAndCleanup(widget):
	"""
	Call close and deleteLater on a widget safely.

	.. note::
		Skips the close call if the widget is already not visible.

	:param widget: Widget to close and delete
	:type widget: QtGui.QWidget
	"""
	if isValid(widget):
		if widget.isVisible():
			widget.close()
		widget.deleteLater()


#Settings management</div>
<div class="viewcode-block" id="getSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.getSettings">[docs]</a>def getSettings(appName, unique=False, version=None):
	"""
	Helper to get a settings object for a given app-name
	It uses INI settings format for Maya, and registry format for stand-alone tools.
	Try to ensure that the appName provided is unique, as overlapping appNames
	will try to load/overwrite each others settings file/registry data.

	:param appName: string -- Application name to use when creating qtSettings ini file/registry entry.
	:return: QtCore.QSettings -- Settings object
	"""
	ukey = __name__ + '_QSettings'
	if not unique and (appName, version) in __main__.__dict__.setdefault('lib.ui.Qt_settings', {}):
		return __main__.__dict__[ukey][(appName, version)]

	if has_maya:
		settingsPath = os.path.join(cmds.internalVar(upd=True), 'qtSettings', appName+'.ini')
		settingsPath = os.path.normpath(settingsPath)
		settings = QtCore.QSettings(settingsPath, QtCore.QSettings.IniFormat)
		settings.setParent(getMayaWindow())
	else:
		settings = QtCore.QSettings('Maya', appName)

	if not unique:
		__main__.__dict__[ukey][(appName, version)] = settings
	elif isinstance(unique, QtCore.QObject):
		settings.setParent(unique)

	if version is not None:
		if float(settings.value('__version__', version))&lt;version:
			settings.clear()
		settings.setValue('__version__', version)
	return settings

</div>
<div class="viewcode-block" id="saveLoadSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.saveLoadSettings">[docs]</a>def saveLoadSettings(widget, ignore=None, save=True, windowStateOnly=False, skipGeometry=False, skipWindowState=None,
                     settings=None):
	"""
	Save/Load state for a widget and it's sub-widgets

	:param widget: Widget to save/load state for
	:type widget: QtGui.QWidget
	:param ignore: widgets to ignore
	:type ignore: list
	:param save: Save if True, load if False
	:type save: bool
	:param windowStateOnly: Save/Load window state only?
	:type windowStateOnly: bool
	:param skipGeometry: Skip geometry when saving/loading?
	:type skipGeometry: bool
	:param settings: Optional QSettings object to save/load from instead of the default
	:type settings: QSettings or InitialSettings
	"""
	if settings is None:
		try:
			settings = widget.settings
		except AttributeError:
			log.exception(
				'Unable to get settings object from widget and no settings object provided... Unable to save settings!\n')
			return

	if skipWindowState is None:
		skipWindowState = skipGeometry

	if save:
		if not skipGeometry:
			settings.setValue('geometry', widget.geometry())
		if not skipWindowState:
			settings.setValue('windowState', widget.saveState())
	else:
		if not skipGeometry:
			geom = settings.value('geometry', None)
			if geom:
				widget.setGeometry(geom)

		if not skipWindowState:
			widget.restoreState(settings.value('windowState', widget.saveState()))

	if windowStateOnly:
		return

	ignored_names = []
	for item in ignore or []:
		if isinstance(item, basestring):
			ignored_names.append(item)
		elif isinstance(item, QtCore.QObject):
			if isValid(item) and widget.objectName():
				ignored_names.append(widget.objectName())

	items = sorted(dir(widget))
	for item in items:
		if (ignore and item in ignored_names) or item.startswith('__'):
			continue
		value = getattr(widget, item)
		if isinstance(value, QtCore.QObject) and hasattr(value, 'objectName'):
			key = value.objectName()
			if not key:
				continue #Don't load un-named objects
			saveLoadState(settings, value, key, save)

</div>
<div class="viewcode-block" id="saveLoadState"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.saveLoadState">[docs]</a>def saveLoadState(settings, widget, key=None, save=True):
	"""
	How to store/load state for a number of widget types

	:param settings: settings object to use
	:type settings: QtCore.QSettings
	:param widget: widget to save
	:type widget: QtGui.QWidget
	:param key: (Optional) key to save it as, uses objectName if None
	:type key: str
	:param save: Save if True, Load if False
	:type save: bool
	"""
	isinstance(settings, QtCore.QSettings)
	if not key:
		key = widget.objectName()
		if not key:
			return

	settings.beginGroup('ControlStates')
	try:
		if not save:
			if not settings.contains(key):
				return
			value = settings.value(key)
			if value == 'false':
				value = False
			elif value == 'true':
				value = True

		if isinstance(widget, QtGui.QCheckBox):
			if save:
				settings.setValue(key, widget.checkState())
			else:
				widget.setCheckState(int(value))
		elif isinstance(widget, QtGui.QAbstractButton) and widget.isCheckable():
			if save:
				settings.setValue(key, widget.isChecked())
			else:
				widget.setChecked(value)
		elif isinstance(widget, QtGui.QComboBox):
			if save:
				settings.setValue(key, widget.currentText())
			else:
				index = widget.findText(value)
				if index &gt;= 0:
					widget.setCurrentIndex(widget.findText(value))
		elif isinstance(widget, QtGui.QLineEdit):
			if save:
				settings.setValue(key, widget.text())
			else:
				widget.setText(value)
		elif isinstance(widget, QtGui.QTextEdit):
			if save:
				settings.setValue(key, widget.toHtml())
			else:
				widget.setHtml(value)
		elif isinstance(widget, QtGui.QTabWidget):
			if save:
				settings.setValue(key, widget.currentIndex())
			else:
				widget.setCurrentIndex(int(value))
		elif isinstance(widget, QtGui.QSplitter):
			if save:
				sizes = widget.sizes()
				if sum(sizes):
					settings.setValue(key, sizes)
			else:
				widget.setSizes([float(v) for v in value])
		elif isinstance(widget, QtGui.QSpinBox) or isinstance(widget, QtGui.QDoubleSpinBox):
			if save:
				settings.setValue(key, widget.value())
			else:
				if isinstance(widget, QtGui.QSpinBox):
					widget.setValue(int(value))
				else:
					widget.setValue(float(value))
		elif isinstance(widget, QtGui.QDateTimeEdit):
			if save:
				settings.setValue(key, widget.dateTime())
			else:
				widget.setDateTime(value)
		elif isinstance(widget, QtGui.QCalendarWidget):
			if save:
				settings.setValue(key, widget.selectedDate())
			else:
				widget.setSelectedDate(value)
		elif isinstance(widget, QtGui.QAbstractSlider):
			if save:
				settings.setValue(key, widget.sliderPosition())
			else:
				widget.setSliderPosition(float(value))
		elif isinstance(widget, QtGui.QHeaderView):
			if save:
				indices = range(widget.count())
				for i in range(widget.count()):
					indices[widget.visualIndex(i)] = i
				settings.setValue(key, widget.saveState())
				settings.setValue(key + '_order', indices)
			else:
				order = settings.value(key + '_order')
				widget.restoreState(value)
				indices = [int(v) for v in order]
				for i, logicalIndex in enumerate(indices):
					widget.moveSection(widget.visualIndex(logicalIndex), i)
		elif isinstance(widget, QtGui.QAction) and widget.isCheckable():
			if save:
				settings.setValue(key, widget.isChecked())
			else:
				widget.setChecked(value)
		elif isinstance(widget, QtGui.QGroupBox) and widget.isCheckable():
			if save:
				settings.setValue(key, widget.isChecked())
			else:
				widget.setChecked(value)
				widget.toggled.emit(value)
	finally:
		settings.endGroup()


###-----------------------------------------------------###
###Maya specific helpers, won't function outside of maya###
###-----------------------------------------------------###</div>
<div class="viewcode-block" id="toQtObject"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.toQtObject">[docs]</a>def toQtObject(mayaName):
	"""
	Given the name of a Maya UI element of any type, return the corresponding QWidget or QAction.
	If the object does not exist, returns None

	:param mayaName: Maya name to get a Qt widget for
	:type mayaName: str
	:return: Widget Object
	:rtype: QtCore.QWidget
	"""
	ptr = apiUI.MQtUtil.findControl(mayaName)
	if ptr is None:
		ptr = apiUI.MQtUtil.findLayout(mayaName)
		if ptr is None:
			ptr = apiUI.MQtUtil.findMenuItem(mayaName)
	return wrapinstance(ptr)

</div>
<div class="viewcode-block" id="getMayaWindow"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.getMayaWindow">[docs]</a>def getMayaWindow():
	"""
	Get the maya main window as a QMainWindow instance

	:return: MainWindow instance
	:rtype: QtGui.QMainWindow
	"""
	try:
		ptr = apiUI.MQtUtil.mainWindow()
		return wrapinstance(ptr)
	except Exception:
		return None

</div>
<div class="viewcode-block" id="widgetToMayaName"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.widgetToMayaName">[docs]</a>def widgetToMayaName(widget):
	"""
	Return the maya full ui path to the given Qt widget

	:param widget: Qt widget to get a Maya path for if possible
	:type widget: QtGui.QWiget or QtCore.QObject
	:return: Maya UI path, or None
	:rtype: str
	"""
	return apiUI.MQtUtil.fullName(unwrapinstance(widget))

</div>
<div class="viewcode-block" id="getParentWidget"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.getParentWidget">[docs]</a>def getParentWidget(widget):
	"""
	Take a given QWidget and return it's Maya UI parent

	:param widget: widget to get parent for
	:type widget: QtGui.QWidget
	:return: Parent widget or None
	:rtype: QtGui.QWidget
	"""
	ptr = apiUI.MQtUtil.getParent(unwrapinstance(widget))
	return wrapinstance(long(ptr))


###------------------------------------------------###
###InitialSettings object for resetSettings support###
###------------------------------------------------###</div>
<div class="viewcode-block" id="InitialSettings"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings">[docs]</a>class InitialSettings(dict):
	"""
	A python dictionary with a similar API to QSettings in order to store
	 a backup of the initial form settings when using loadUiFile
	"""

	def __init__(self, *args):
		super(InitialSettings, self).__init__(*args)
		self._group = []

<div class="viewcode-block" id="InitialSettings.getGroupKey"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.getGroupKey">[docs]</a>	def getGroupKey(self, key):
		return '/'.join(self._group + [key])
</div>
<div class="viewcode-block" id="InitialSettings.setValue"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.setValue">[docs]</a>	def setValue(self, key, value):
		self[self.getGroupKey(key)] = value
</div>
<div class="viewcode-block" id="InitialSettings.value"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.value">[docs]</a>	def value(self, key, default=None):
		return self.get(self.getGroupKey(key), default)
</div>
<div class="viewcode-block" id="InitialSettings.contains"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.contains">[docs]</a>	def contains(self, key):
		return self.getGroupKey(key) in self
</div>
<div class="viewcode-block" id="InitialSettings.beginGroup"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.beginGroup">[docs]</a>	def beginGroup(self, groupName):
		self._group.append(groupName)
</div>
<div class="viewcode-block" id="InitialSettings.endGroup"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.endGroup">[docs]</a>	def endGroup(self):
		self._group.pop(-1)
</div>
<div class="viewcode-block" id="InitialSettings.group"><a class="viewcode-back" href="../../../mlib/core/qt.html#mlib.core.qt.InitialSettings.group">[docs]</a>	def group(self):
		return '/'.join(self._group)</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Maya open source Python/Qt tools 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Nathan Horne.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2pre.
    </div>
  </body>
</html>